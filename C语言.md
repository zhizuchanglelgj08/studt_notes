# C语言

## Day1	课程内容介绍

数据结构 + 算法 = 程序

数据 + 逻辑 = 程序

----------------------------------------------王道在线

**第一阶段**

**（C语言及项目实战）**

**Week1**

- 学习C语言的目的，C的基本数据类型，整型(各种进制变换及补码)，浮点型，字符型等
- C语言的13种类型运算符及表达式
- 选择循环结构程序设计
- 一维二维数组存储原理及灵活使用
- 指针的本质，指针的偏移与传递，一级指针(基本类型指针，数组指针，函数指针等)，二级指针
- 函数的使用，函数内不同变量的作用域及有效期等

**Week2**

-  结构体，链表的增删改查，联合体，枚举，从链表延伸各种高级数据结构等
- 常用数据结构栈，队列，二叉树，哈希等增删查改，红黑树的增删查改，基本排序算法(冒泡，选择，插入，快排，堆排)等，对比不同排序算法掌握时间复杂度，理解空间复杂度等，掌握常用排序接口qsort，同时实现索引式排序，理解索引本质；针对顺序查找，二分查找，哈希查找，红黑树查找等不同场景的查找进行时间复杂度对比分析。
- 文件的打开，读写，偏移，关闭等
- 2019年针对2018年王道学员面试中遇到的C语言题目，各种数据结构及算法类的相关题目进行总结加入，从而让大家能够更加扎实的数据结构，常用算法，为面试做好充分的准备
- 学生管理系统项目实战(通过学生管理系统掌握用户登录，文件中链式数据结构的初始化，程序的结构化设计，文件的新建修改存储等)
- 编译器项目，讲解词法分析，语法分析的设计，编译器流程，从而能够完成基本的词法分析器，语法分析器，为一旦进行任何一个公司编写对应公司编码规范的静态代码检查工具做好充分准备，同时也为考研复试面试加分。

**第二阶段**

**（Linux服务器开发及项目实战）**

**Week1**

-  Linux概述，为什么学习Linux系统编程，掌握系统编程后以后可以从事哪些方面的工作，掌握操作系统的三层结构，POSIX标准，准确把握学习方向等
-  Linux常用命令，通过命令能够在Linux下熟练进行各种操作(用户创建配置，文件及目录新增删除查找，权限改变，文件内容查找，磁盘内存查看，远程数据COPY等)
-  VIM编辑器，能够熟练编写代码，自动对齐，联想，批量替换等操作灵活掌握
-  GCC编译器，掌握预处理，编译，汇编，链接每个过程文件实际变化，动态库、静态库编写，生成，调用、GDB调试，能够灵活打断点，看内存，调用堆栈等
-  Makefile工程管理器，能够编写通用性强的Makefile
-  Linux文件操作编程，通过Linux的文件操作接口实现文件的打开(多种模式均需掌握)，读写，关闭。Stat文件状态获取，DIR系列接口能够自行实现目录深度优先，广度优先遍历，文件空洞设计，mmap文件映射高效操作文件，使用管道文件通信掌握select多路复用等
-  通过Linux一系列文件操作，掌握VFS文件系统原理，解析iNode与Dentry存储原理，B+树存储结构等，为以后理解各种文件系统，数据库，大数据框架的实现做好准备

**Week2**

- Linux多进程机制，进程的调度，进程的创建，退出，资源回收等，通过对进程RSTZ等状态变化的把握，理解调度本质，队列思想，并发与并行，负载均衡等
- 进程间通信、标准流管道，无名管道，有名管道编程，能够通过管道灵活实现各种情况下的进程间通信
- 共享内存创建，连接，使用，删除等，掌握虚拟地址到物理地址的转换原理，理解共享内存与Mmap的差异
- 信号量原理解析，原子操作分析，能够使用信号量保护共享资源，计数信号量理解生产者消费者模式
- 信号的产生，处理，阻塞等操作，能够熟练进行信号处理行为设定，充分理解异步原理

**Week3**

- Linux多线程原理，线程的创建，退出，资源回收等
- 线程的取消，取消失败分析，异步取消的资源清理等
- 线程互斥锁mutex、线程条件变量同步机制，深入理解同步及异步编程等
- 可重入函数，不可重复函数
- 网络编程模型解析，网络协议解析等

**Week4**

- Socket编程基本原理讲解，通过Socket实现TCP、UDP通信
- Select，epoll多路复用讲解，实现原理，并发处理等
- Socket结合epoll实现即时通信，文件传输等
- 进程池模型讲解，通过进程池实现文件的并行下载
- 线程池模型讲解，通过线程池实现文件的并行下载

**Week5**

- Mysql安装配置，数据库及表的创建删除，表的增删改查，销毁等，C连接Mysql进行增删改查
- Mysql索引讲解，索引是什么，为什么需要索引，目前索引的类型及索引的内部实现原理
- 单元测试方法(等价类，边界值，因果图，判定表，状态机，正交分析法等测试方法讲解)
- 通用加密算法解析，散列算法，对称加密，非对称加密算法等
- 性能调优讲解，涉及Perf使用，零COPY技术等
- 负载均衡技术讲解，如何通过负载均衡实现高并发
- valgrind内存泄漏检测工具memcheck使用讲解
- libevent中间件下载编译，安装使用，掌握libevent如何监控读，写，异常等事件，掌握学习中间件的基本方法，为以后学习中间件做好准备。
- 2019年针对2018年王道学员面试中遇到的Linux系统编程的文件系统，调度，内存管理，网络编程等题目，进行归纳总结，加入课件思考题，每日作业，从而让面试更稳！
- **文件服务器项目实战(功能匹配百度网盘)**
- (包括
- 用户注册，登录验证，文件查看，上传，下载，删除
- 下载具备下载提速，断点续传，多点下载等功能
- 服务器文件系统升级，实现不同用户相同文件秒传功能
- 长连接分类，不同业务分配给不同线程，降低线程睡眠唤醒次数，提高并发量
- 轮盘法监控客户端连接，长时间无操作断开机制
- 文件授权查看功能，类似百度网盘分享
- 

**第一阶段****
**(C++语言基础4周)**

**Week1**

- Git版本控制系统
- Vim编辑器IDE化
- C++与C语言的差别，字符串类型std::string
- 类的定义，三种访问修饰符，对象的创建和销毁
- 设计模式之单例模式
- new/delete表达式扩展
- 容器之vector
- C++输入输出流
- 日志系统log4cpp的学习

**Week2**

- 友元函数、友元类
- C++运算符重载
- 全局类，嵌套类，局部类；
- 设计模式之Pimpl,Singleton变种
- 写时复制(COW)技术详解
- 设计模式之代理模式
- xml文件解析(开源库TinyXml2)
- 正则表达式匹配字符串(开源库Boost.Regex)
- 泛型编程，模板，函数模板，类模板

**Week3**

- 标准模板库STL总体概述
- STL六大组件：容器、迭代器、适配器、算法、函数对象、空间配置器
- STL迭代器源码剖析
- STL容器适配器、迭代器适配器、算法适配器
- STL空间配置器底层源码剖析
- 实现自定义Vector类

**Week4**

- C++11新特性之移动语义
- 资源管理之RAII技术，智能指针
- 数据格式之JSON字符串解析
- 面向对象之继承，基类，派生类对象的创建和销毁，基类与派生类对象间的转换，派生类对象间的转换
- 面向对象之多态，虚函数的实现原理，虚函数的访问，纯虚函数，抽象类
- 面向对象设计原则，UML，类图，序列图
- 设计模式之工厂模式，观察者模式

**第二阶段**

**（C++进阶）**

**Week5**

- 使用C++封装POSIX线程
- 生产者-消费者问题，互斥锁，条件变量，线程
- 线程池封装
- 并发服务器模型详解，socket编程
- TCP协议，同步/异步，阻塞/非阻塞
- IO复用模型，网络IO模型
- Reactor模式、Proactor模式特点
- 网络库TcpServer框架实现
- Linux下timerfd/eventfd封装
- 2019年针对2018年王道学员在面试中关于C++中遇到的数据结构、设计模式、项目有关等题目，进行归纳总结，加入到平常的课程与作业之中，给予学生更多的引导作用，从而促进面试更顺利地通过！

**第三阶段**

**（C++项目开发）**

**Week6**

**项目一：文本纠错**

- 使用IO流创建词典和索引文件
- 将线程池与网络库结合起来搭建服务器框架
- 根据业务逻辑响应客户端的请求
- 为了提高程序的查询效率，实现缓存系统
- 使用分词库cppjieba处理中文

**Week7**

**项目二:** **基于RSS的内容定制化搜索引擎**

- 搜索引擎概述
- 使用开源库log4cpp处理日志
- 基于RSS文件建立网页库,网页偏移库
- 采用TF-IDF算法建立倒排索引库
- 采用余弦相似度算法对网页进行排序
- 根据查询词自动生成文档摘要
- 将计算结果打包成JSON数据报返回给客户端

## Day2	数据类型，运算符与表达式

inter CPU小端，低位在前

### 2.1	程序的编译过程

编写.c源代码文件，编写完毕后，通过编译器进行编译，这里的编译包含预处理，编译，汇编，链接。

[https://blog.csdn.net/hemeinvyiqiluoben/article/details/84867366](c语言编译过程详解)

### 2.2	数据类型

基本类型：整型int、字符型char、实型/浮点型（单精度实型float，双精度实型double）

构造类型：数组类型[]、结构类型struct、联合类型union、枚举类型enum。

指针类型：*

空类型（无值类）：void

**常量赋值给变量**

常量：在程序运行期间，其值不能被改变的量。

变量：代表内存中具有特定属性的一个存储单元，它用来存放数据，即一个内存地址名。

**常量定义：是指定义符号常量。作为符号常量名，一般大写。** <u>格式：#define标识符常量</u> 

位（bit），共32位

0000	0000	0000	0000	0000	0000	0000	0001

字节（byte），1字节	=	8位

0000	0000	0000	0001

1KB = 1024byte	（磁盘厂商 1kb = 1000byte	宽带 10Mb/S 是以位来算的  10Mb/s / 8bit）

1MB = 1024KB

### 2.3	补码的作用

计算机的CPU是无法做减法运算的，只能做加法。

补码的作用，补码的引入是为了方便减法的运算。

5	  0000	0101

取反加1

-5	1111	1010 	+	1	=	1111	1011

>  首先灌输一个新的概念叫，模。什么是“模”，想象日常使用的钟表，它可以显示0～12点的时间，假设现在是2点钟，请用手动拨动时针的方式将时间减4小时，你会怎么做？
> 有两种方式： 
>
> 1. 逆时针将时针拨4小时
> 2. 顺时针将时针拨8（12-4）小时
>
> 这里要讲的是第二种方式，为什么顺时针拨12-4也可以达到和正常思维的第一种方式一样的位置。
> 12就是模。
> 同样的，如果是十进制的两位数，80-10 和 80＋90在不考虑百位数的基础上都是70。这里的90就是100-10得来的，这种情况下100就是模
> 模就好比是一个极限，在它的范围内，两个相加等于模的数互为补数，还是举100的例子
> 90和10， 55和45，68和32，互为补数
> 在模的范围内做减法，可以将“X－Y”的减法变更为“X＋Y的补数“的加法，当然前提是不考虑百位数
>
> 思考题，*上面举的例子是大数减小数，那么如果是小数减大数会怎么样呢？*
> 如果是10-80，结果应该是－70，但如果按照10+（100-80），结果是30。
> 而很明显－70和30不是一回事，这里也没有百位数的问题，这种情况应该怎么破？
> 当初的那些先贤们想出来的办法很简单，就是把这两个数直接划上等号，正好顺便解决了负数的表达方式。再来仔细看看这两个数的关系：－70绝对值的补数就正好是30
> 所以在计算机中，**负数的表达方式就是它绝对值的补数**
> 但是问题又来了，看起来这个解决方式很完美了，但别忘了，30他已经代表了正数的30了，现在又要用来代表负数的－70，谁知道它出现的时候到底是代表哪个数？
> 为了解决这个问题，需要给这套规则划定一个范围，原来是0～99的正数，现在既然要用部分正数来代替负数了，那就要规定一个范围来使得一个数只代表一个含义，正好一人一半，0～49这个区间就代表正数，50～99的区间就用来代表各自补数的负值，例：98就代表－2
> ｜
>  V
>
> 现在回到二进制的计算机世界
> 8位二进制数一共可以表示2的8次方，256个数，即0～255 （别忘了0也要占一位的），他们的极限就是256，即256是8位二进制数的模 ，应该不难理解吧，同上十进制的两位数0～99的模是100。
> 还是用二进制来说明清楚，8位二进制能表示的数的极限是
> 1 1 1 1 1 1 1 1， 就是255，在这基础上加0 0 0 0 0 0 0 1，出现了进一位 即 1 0 0 0 0 0 0 0 0
> 这个1 0 0 0 0 0 0 0 0就是8位二进制数的模，256
>
> 同样按照第二步讲的逻辑，一半的数0～127，代表其正数本身，另一半的数 128～255，代表其补数的负值，即“－1～－128”的区间。 
> 而 “X－Y”的减法 就用 “X＋Y的补数” 的加法来表示，完美！ 唯一需要注意的事情是任何计算的输入值和输出结果值都需要严格遵守－128～127的范围，一旦溢出就会报错。
> 这也就是我们在编程里强调的为什么 byte＋byte还得是byte，int＋int还得是int，数据溢出问题也是每一个程序员都需要注意的问题。
>
> 这样一说是不是可以理解－128的补码是怎么来的了吧？ 他就是256-｜－128｜＝128
> 二进制的128是不是就是1 0 0 0 0 0 0 0 ？
> ｜
>  V
>
> 最终问题，那书和老师为什么要用原码，反码来讲补码 ?







# 作业

```c
//作业
/**

*	1.打印九九乘法表
  2.打印菱形。空菱形，心型
  3.求两个有序数组的公共元素、求三个数组的公共元素、求n个有序数组的公共元素
  4.求数组的最大值和次大值。
  5.给定一个n个整型元素的数组a，其中一个元素出现次数超过n/2，s求这个元素。
  6.给定一个含有n个元素的整型数组，找出数组中的两个元素x和y，使得abs（x-y）值最小。abs()绝对值函数
  7.给定含有1001个元素的数组，其中存放了1-1000之内的整数，只有一个整数是重复的，请找出这个数
  	A1+....+A1001-(1+...+1000)

*/
```

